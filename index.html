<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Holy Quran Mushaf App</title>
  <style>
    :root {
      --bg: #f6fbff;
      --bg2: #e7f2ff;
      --panel: #ffffff;
      --panel2: #f2f8ff;
      --text: #173651;
      --muted: #5f7c99;
      --accent: #15a879;
      --accent-soft: rgba(21, 168, 121, 0.16);
      --gold: #b7862f;
      --border: rgba(20, 61, 95, 0.16);
      --danger-bg: rgba(255, 89, 89, 0.13);
      --danger-border: rgba(205, 51, 51, 0.4);
      --radius: 14px;
      --shadow: 0 16px 40px rgba(19, 59, 92, 0.15);
    }

    * { box-sizing: border-box; }
    html, body { margin: 0; min-height: 100%; scroll-behavior: smooth; }
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: var(--text);
      background:
        radial-gradient(circle at 12% 10%, #bfe7ff 0%, transparent 30%),
        radial-gradient(circle at 87% 0%, #d2f7e7 0%, transparent 34%),
        linear-gradient(155deg, #f8fcff, #eaf4ff 55%, #f3fbff);
    }
    body.translation-off .translation-text { display: none; }
    .hidden { display: none !important; }

    .app-shell {
      display: grid;
      grid-template-columns: 315px 1fr;
      min-height: 100vh;
    }

    .sidebar {
      position: sticky;
      top: 0;
      height: 100vh;
      overflow-y: auto;
      padding: 16px;
      border-right: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.9), rgba(245, 251, 255, 0.92));
      backdrop-filter: blur(12px);
    }

    .brand { margin-bottom: 14px; }
    .brand h1 { margin: 0; color: var(--gold); font-size: 1.2rem; }
    .brand p { margin: 6px 0 0; color: var(--muted); font-size: 0.86rem; }

    .controls { display: grid; gap: 10px; margin-bottom: 14px; }
    .inline-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .input, .select {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #ffffff;
      color: var(--text);
      padding: 10px 11px;
      font-size: 0.92rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .input:focus, .select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-soft);
    }

    .page-jump { display: grid; grid-template-columns: 1fr auto; gap: 8px; }
    .session-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .toggle-row {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #ffffff;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      color: var(--muted);
      font-size: 0.9rem;
      min-height: 40px;
    }
    .toggle-row input { accent-color: var(--accent); width: 16px; height: 16px; cursor: pointer; }
    .range-row {
      display: grid;
      grid-template-columns: 1.2fr 0.4fr 0.4fr;
      gap: 8px;
      align-items: center;
    }
    .progress-config {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #ffffff;
      padding: 9px 10px;
      display: grid;
      gap: 6px;
    }
    .progress-config label {
      font-size: 0.8rem;
      color: var(--muted);
      font-weight: 600;
    }

    .status-card {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.75);
      padding: 10px;
      margin-bottom: 10px;
    }
    .status-card h3 {
      margin: 0 0 8px;
      font-size: 0.9rem;
      color: var(--text);
    }
    .section-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      margin-bottom: 8px;
    }
    .mini-btn {
      border: 1px solid rgba(32, 107, 164, 0.25);
      background: linear-gradient(120deg, #ffffff, #ecf6ff);
      color: var(--text);
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 0.75rem;
      cursor: pointer;
    }
    .mini-btn:hover {
      border-color: var(--accent);
      background: #effaf4;
    }
    .progress-stats {
      display: grid;
      gap: 4px;
      color: var(--muted);
      font-size: 0.8rem;
    }
    .bookmark-list {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 6px;
      max-height: 170px;
      overflow: auto;
    }
    .bookmark-item {
      border: 1px solid var(--border);
      border-radius: 9px;
      background: #fff;
      padding: 7px 8px;
      font-size: 0.78rem;
      color: var(--muted);
      display: grid;
      gap: 5px;
    }
    .bookmark-item button {
      width: fit-content;
      border: 1px solid rgba(32, 107, 164, 0.25);
      border-radius: 7px;
      background: #fff;
      color: var(--text);
      font-size: 0.74rem;
      cursor: pointer;
      padding: 3px 7px;
    }
    .bookmark-item button:hover {
      border-color: var(--accent);
      background: #f2fbf7;
    }

    .surah-list { list-style: none; margin: 0; padding: 0; display: grid; gap: 6px; }
    .surah-btn {
      width: 100%;
      text-align: left;
      border: 1px solid transparent;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.45);
      color: var(--text);
      cursor: pointer;
      padding: 10px 11px;
      display: grid;
      gap: 2px;
      transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
    }
    .surah-btn:hover {
      transform: translateY(-2px);
      border-color: rgba(21, 168, 121, 0.45);
      background: linear-gradient(120deg, #f8fffc, #eff8ff);
      box-shadow: 0 8px 18px rgba(21, 97, 161, 0.12);
    }
    .surah-btn.active {
      border-color: var(--accent);
      background: linear-gradient(120deg, rgba(21, 168, 121, 0.18), rgba(21, 135, 200, 0.12));
    }
    .surah-title { font-size: 0.92rem; font-weight: 600; }
    .surah-sub { font-size: 0.78rem; color: var(--muted); }

    .content { padding: 18px 14px 88px; }
    .top-panel {
      position: sticky;
      top: 10px;
      z-index: 8;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.94), rgba(244, 250, 255, 0.95));
      box-shadow: var(--shadow);
      padding: 14px;
      margin-bottom: 14px;
    }
    .top-panel h2 { margin: 0; color: var(--text); font-size: clamp(1.08rem, 2.4vw, 1.45rem); }
    .top-panel p { margin: 6px 0 0; color: var(--muted); font-size: 0.88rem; }
    .toolbar { margin-top: 12px; display: flex; flex-wrap: wrap; gap: 8px; }
    .practice-row {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .btn {
      border: 1px solid transparent;
      border-radius: 10px;
      padding: 8px 12px;
      color: var(--text);
      background: #ffffff;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      transition: transform 0.2s ease, filter 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .btn:hover:not(:disabled) {
      transform: translateY(-2px);
      filter: brightness(1.03);
      box-shadow: 0 10px 20px rgba(24, 90, 138, 0.16);
    }
    .btn:active:not(:disabled) { transform: translateY(0); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-primary { background: linear-gradient(120deg, #12a86f, #15b39f); color: #f4fffb; border-color: rgba(18, 168, 111, 0.5); }
    .btn-secondary { border-color: rgba(32, 107, 164, 0.25); background: linear-gradient(120deg, #ffffff, #ecf6ff); }
    .status-row { margin-top: 10px; color: var(--muted); font-size: 0.86rem; }
    .kbd-hint {
      margin-top: 7px;
      color: var(--muted);
      font-size: 0.76rem;
    }

    .loading {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #ffffff;
      padding: 12px;
      color: var(--muted);
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.92rem;
    }
    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid rgba(21, 96, 152, 0.2);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.85s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .error-banner {
      border: 1px solid var(--danger-border);
      background: var(--danger-bg);
      color: #7d1f1f;
      border-radius: 12px;
      padding: 12px;
      font-size: 0.9rem;
      margin-bottom: 12px;
    }

    .book-stage { max-width: 1200px; margin: 0 auto; perspective: 1200px; }
    .book-spread {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      align-items: start;
    }
    .book-spread.dual {
      grid-template-columns: 1fr 1fr;
    }
    .book-page {
      position: relative;
      border: 1px solid rgba(183, 134, 47, 0.28);
      border-radius: 18px;
      box-shadow: var(--shadow);
      background:
        linear-gradient(90deg, rgba(183, 134, 47, 0.08), rgba(183, 134, 47, 0.02) 12%, rgba(183, 134, 47, 0.08) 88%, rgba(183, 134, 47, 0.02)),
        linear-gradient(180deg, #ffffff, #f8fcff 70%, #f1f8ff);
      overflow: hidden;
      animation: pageIn 0.32s ease;
    }
    .page-badge {
      padding: 8px 14px 4px;
      color: #5f7c99;
      font-size: 0.78rem;
      font-weight: 700;
      letter-spacing: 0.2px;
      border-bottom: 1px solid rgba(20, 61, 95, 0.1);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.5), rgba(236, 247, 255, 0.35));
    }
    .book-page::before {
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      left: 50%;
      width: 1px;
      background: linear-gradient(180deg, transparent, rgba(183, 134, 47, 0.35), transparent);
    }
    @keyframes pageIn { from { opacity: 0.3; transform: rotateY(5deg) scale(0.99); } to { opacity: 1; transform: rotateY(0deg) scale(1); } }
    .book-inner { max-height: calc(100vh - 245px); overflow: auto; padding: 16px; display: grid; gap: 10px; }

    .surah-divider {
      border: 1px solid rgba(183, 134, 47, 0.28);
      background: rgba(183, 134, 47, 0.1);
      color: #805a13;
      border-radius: 999px;
      padding: 6px 12px;
      width: fit-content;
      margin: 4px auto 2px;
      font-size: 0.82rem;
      font-weight: 600;
    }

    .ayah-card {
      border: 1px solid rgba(23, 72, 110, 0.14);
      border-radius: 12px;
      padding: 12px;
      background: linear-gradient(180deg, #ffffff, #f2f8ff);
      transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .ayah-card:hover { transform: translateY(-2px); border-color: rgba(21, 168, 121, 0.45); box-shadow: 0 12px 24px rgba(24, 90, 138, 0.13); }
    .ayah-card.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(21, 168, 121, 0.35), 0 12px 24px rgba(16, 85, 132, 0.16);
      background: linear-gradient(180deg, #f7fffb, #edf8ff);
    }
    .ayah-header { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 8px; }
    .ayah-actions {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .ayah-number { color: var(--gold); font-size: 0.83rem; font-weight: 700; }
    .ayah-btn {
      border: 1px solid var(--border);
      border-radius: 9px;
      background: #ffffff;
      color: var(--text);
      cursor: pointer;
      font-size: 0.82rem;
      padding: 6px 10px;
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    .ayah-btn:hover { border-color: var(--accent); background: #eef9ff; }
    .ayah-btn.is-playing { border-color: var(--accent); background: rgba(21, 168, 121, 0.2); color: #0f5f45; }
    .ayah-btn.saved { border-color: #b7862f; background: rgba(183, 134, 47, 0.12); color: #6d4b16; }
    .arabic-text {
      margin: 0;
      direction: rtl;
      text-align: right;
      line-height: 2.05;
      font-size: clamp(1.5rem, 3.15vw, 1.98rem);
      color: #112f49;
      font-family: "Traditional Arabic", "Scheherazade New", "Amiri", "Noto Naskh Arabic", serif;
    }
    .word-chip {
      cursor: pointer;
      border-radius: 6px;
      padding: 0 2px;
      transition: background 0.18s ease, color 0.18s ease;
    }
    .word-chip.cursor-read {
      background: rgba(21, 168, 121, 0.14);
      color: #0f5f45;
    }
    .word-chip.cursor-active {
      background: linear-gradient(120deg, rgba(21, 168, 121, 0.27), rgba(42, 134, 226, 0.18));
      color: #0a3f30;
      box-shadow: 0 0 0 1px rgba(21, 168, 121, 0.28), 0 6px 14px rgba(14, 93, 141, 0.18);
      animation: wordPulse 0.95s ease-in-out infinite alternate;
    }
    .word-chip:hover {
      background: rgba(21, 168, 121, 0.14);
      color: #0f5f45;
    }
    @keyframes wordPulse {
      from { transform: translateY(0); }
      to { transform: translateY(-1px); }
    }
    .tajweed-letter { font-weight: 700; }
    .tajweed-ghunnah { color: #0f9ac2; }
    .tajweed-madd { color: #a26eec; }
    .tajweed-qalqalah { color: #db5c5c; }
    .tajweed-lafz { color: #b7862f; font-weight: 700; }
    .translation-text {
      margin: 10px 0 0;
      border-top: 1px solid rgba(23, 72, 110, 0.12);
      padding-top: 9px;
      color: #4f6d89;
      font-size: 0.97rem;
      line-height: 1.72;
    }
    .empty-state {
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 15px;
      text-align: center;
      color: var(--muted);
      background: rgba(255, 255, 255, 0.6);
    }
    .player-bar {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      border-top: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.92);
      backdrop-filter: blur(8px);
      padding: 10px 14px;
      color: var(--muted);
      font-size: 0.9rem;
      z-index: 20;
    }
    .word-tooltip {
      position: fixed;
      z-index: 40;
      max-width: 240px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.98);
      box-shadow: 0 14px 28px rgba(17, 78, 123, 0.18);
      padding: 8px 10px;
      color: var(--text);
      font-size: 0.78rem;
      line-height: 1.45;
      pointer-events: none;
    }
    .word-tooltip .raw-word {
      color: #275073;
      font-size: 0.92rem;
      direction: rtl;
      text-align: right;
      margin-bottom: 4px;
      font-family: "Traditional Arabic", "Scheherazade New", "Amiri", "Noto Naskh Arabic", serif;
    }
    .word-tooltip .meta {
      color: var(--muted);
    }

    @media (max-width: 980px) {
      .app-shell { grid-template-columns: 1fr; }
      .sidebar { position: static; height: auto; border-right: none; border-bottom: 1px solid var(--border); }
      .content { padding-top: 12px; }
      .book-inner { max-height: none; }
      .book-spread.dual { grid-template-columns: 1fr; }
      .inline-controls { grid-template-columns: 1fr; }
      .session-row { grid-template-columns: 1fr; }
      .range-row { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <aside class="sidebar">
      <div class="brand">
        <h1>Holy Quran</h1>
        <p>Mushaf view, page by page recitation.</p>
      </div>
      <div class="controls">
        <input id="searchInput" class="input" type="text" placeholder="Search Surah..." />
        <select id="reciterSelect" class="select" aria-label="Select reciter"></select>
        <select id="translationSelect" class="select" aria-label="Select translation"></select>
        <select id="audioTranslationSelect" class="select" aria-label="Select audio translation"></select>

        <div class="session-row">
          <select id="sessionModeSelect" class="select" aria-label="Select session mode"></select>
          <label class="toggle-row" for="dualPageToggle">
            <input id="dualPageToggle" type="checkbox" />
            <span>Dual-Page Spread</span>
          </label>
        </div>

        <div class="page-jump">
          <input id="pageInput" class="input" type="number" min="1" max="604" placeholder="Page (1-604)" />
          <button id="goPageBtn" class="btn btn-secondary" type="button">Go</button>
        </div>

        <div class="inline-controls">
          <label class="toggle-row" for="translationToggle">
            <input id="translationToggle" type="checkbox" checked />
            <span>Show Translation</span>
          </label>
          <label class="toggle-row" for="tajweedToggle">
            <input id="tajweedToggle" type="checkbox" />
            <span>Tajweed Mode</span>
          </label>
        </div>

        <div class="inline-controls">
          <label class="toggle-row" for="continueQueueToggle">
            <input id="continueQueueToggle" type="checkbox" />
            <span>Continue Next Page</span>
          </label>
          <label class="toggle-row" for="pageLoopToggle">
            <input id="pageLoopToggle" type="checkbox" />
            <span>Loop Page/Range</span>
          </label>
        </div>

        <div class="inline-controls">
          <select id="repeatCountSelect" class="select" aria-label="Repeat ayah count"></select>
          <select id="speedSelect" class="select" aria-label="Recitation speed"></select>
        </div>

        <div class="range-row">
          <label class="toggle-row" for="rangeRepeatToggle">
            <input id="rangeRepeatToggle" type="checkbox" />
            <span>Repeat Range</span>
          </label>
          <input id="rangeStartInput" class="input" type="number" min="1" value="1" />
          <input id="rangeEndInput" class="input" type="number" min="1" value="1" />
        </div>

        <div class="progress-config">
          <label for="dailyGoalInput">Daily Goal (pages)</label>
          <input id="dailyGoalInput" class="input" type="number" min="1" max="50" value="5" />
        </div>
      </div>

      <section class="status-card">
        <h3>Progress</h3>
        <div id="progressStats"></div>
      </section>

      <section class="status-card">
        <div class="section-head">
          <h3>Bookmarks</h3>
          <button id="clearBookmarksBtn" class="mini-btn" type="button">Clear</button>
        </div>
        <ul id="bookmarkList" class="bookmark-list"></ul>
      </section>
      <ul id="surahList" class="surah-list"></ul>
    </aside>
    <main class="content">
      <section class="top-panel">
        <h2 id="pageTitle">Loading...</h2>
        <p id="pageMeta">Please wait while Quran data loads.</p>
        <div class="toolbar">
          <button id="prevPageBtn" class="btn btn-secondary" disabled>Previous Page</button>
          <button id="nextPageBtn" class="btn btn-secondary" disabled>Next Page</button>
          <button id="playPageBtn" class="btn btn-primary" disabled>Play Full Page</button>
          <button id="globalPlayPauseBtn" class="btn btn-secondary" disabled>Play</button>
        </div>
        <div class="practice-row">
          <button id="practiceRecordBtn" class="btn btn-secondary" type="button" disabled>Start Practice</button>
          <button id="practicePlayBtn" class="btn btn-secondary" type="button" disabled>Play My Recitation</button>
        </div>
        <div id="nowPlaying" class="status-row">Not playing</div>
        <div id="practiceStatus" class="status-row">Practice mode ready</div>
        <div class="kbd-hint">Shortcuts: Space play/pause | Left/Right page | Up/Down ayah</div>
      </section>
      <div id="loadingIndicator" class="loading hidden">
        <span class="spinner"></span>
        <span id="loadingText">Loading...</span>
      </div>
      <div id="errorBanner" class="error-banner hidden"></div>
      <section class="book-stage">
        <div id="bookSpread" class="book-spread">
          <article class="book-page">
            <div id="mainPageBadge" class="page-badge">Page</div>
            <div id="ayahContainer" class="book-inner"></div>
          </article>
          <article id="secondaryPageCard" class="book-page hidden">
            <div id="secondaryPageBadge" class="page-badge">Page</div>
            <div id="ayahContainerSecondary" class="book-inner"></div>
          </article>
        </div>
      </section>
    </main>
  </div>
  <div id="playerBar" class="player-bar">Ready</div>
  <div id="wordTooltip" class="word-tooltip hidden"></div>
  <audio id="globalAudio" preload="none"></audio>
  <audio id="practiceAudio" preload="none"></audio>
  <script>
    const API_BASE = "https://api.alquran.cloud/v1";
    const TOTAL_PAGES = 604;
    const RECITERS = [
      { id: "ar.alafasy", label: "Mishary Alafasy" },
      { id: "ar.abdulbasitmurattal", label: "Abdul Basit (Murattal)" },
      { id: "ar.abdurrahmaansudais", label: "Abdur Rahman Al-Sudais" },
      { id: "ar.husary", label: "Mahmoud Khalil Al-Husary" }
    ];
    const TRANSLATIONS = [
      { id: "en.sahih", label: "Saheeh International" },
      { id: "en.pickthall", label: "Pickthall" },
      { id: "en.yusufali", label: "Yusuf Ali" },
      { id: "en.asad", label: "Muhammad Asad" }
    ];
    const AUDIO_TRANSLATIONS = [
      { id: "none", label: "Audio Translation: Off" },
      { id: "en.walk", label: "Audio Translation: English (Ibrahim Walk)" },
      { id: "ur.khan", label: "Audio Translation: Urdu (Shamshad Ali Khan)" }
    ];
    const SESSION_MODES = [
      { id: "read", label: "Read Mode" },
      { id: "listen", label: "Listen Mode" },
      { id: "memorize", label: "Memorize Mode" },
      { id: "reflect", label: "Reflect Mode" }
    ];
    const SPEED_OPTIONS = [0.75, 1, 1.25, 1.5];
    const REPEAT_OPTIONS = [1, 2, 3, 5, 10];
    const WORD_MEANINGS = {
      الله: "Allah",
      رب: "Lord",
      رحمن: "Most Merciful",
      رحيم: "Especially Merciful",
      يوم: "Day",
      دين: "Judgment / Recompense",
      صراط: "Path",
      مستقيم: "Straight",
      اهدنا: "Guide us",
      اياك: "You alone",
      نعبد: "We worship",
      نستعين: "We ask for help"
    };
    const TRANSLIT_MAP = {
      ا: "a", أ: "a", إ: "i", آ: "aa", ب: "b", ت: "t", ث: "th", ج: "j", ح: "h", خ: "kh",
      د: "d", ذ: "dh", ر: "r", ز: "z", س: "s", ش: "sh", ص: "s", ض: "d", ط: "t", ظ: "z",
      ع: "a", غ: "gh", ف: "f", ق: "q", ك: "k", ل: "l", م: "m", ن: "n", ه: "h", و: "w",
      ي: "y", ة: "h", ى: "a", ئ: "i", ؤ: "u", ء: "'"
    };
    const STORAGE_KEYS = {
      lastPage: "quran_last_page",
      reciter: "quran_reciter",
      translation: "quran_translation",
      settings: "quran_settings",
      bookmarks: "quran_bookmarks",
      progress: "quran_progress"
    };

    const state = {
      surahs: [],
      ayahs: [],
      surahStartPageCache: {},
      currentPage: 1,
      currentReciter: RECITERS[0].id,
      currentTranslation: TRANSLATIONS[0].id,
      currentAudioTranslation: AUDIO_TRANSLATIONS[0].id,
      sessionMode: SESSION_MODES[0].id,
      dualPageEnabled: false,
      currentAyahIndex: -1,
      currentAyahRepeatLeft: 1,
      currentPlaybackPhase: "arabic",
      isFullPageMode: false,
      searchTerm: "",
      continueAcrossPages: false,
      pageLoop: false,
      rangeRepeatEnabled: false,
      rangeStart: 1,
      rangeEnd: 1,
      repeatAyahCount: 1,
      playbackRate: 1,
      tajweedMode: false,
      translationVisible: true,
      dailyGoal: 5,
      pendingHighlightAyahNumber: null,
      secondaryPage: null,
      secondaryAyahs: [],
      ayahDurationCache: {},
      practiceRecordings: {},
      practiceMediaRecorder: null,
      practiceStream: null,
      practiceChunks: [],
      practiceActiveAyahNumber: null,
      practiceRecordingStartMs: 0,
      practiceIsRecording: false,
      bookmarks: [],
      progress: {
        completedPages: [],
        pageHistory: {},
        streak: 0,
        lastActiveDate: ""
      }
    };

    const els = {
      searchInput: document.getElementById("searchInput"),
      reciterSelect: document.getElementById("reciterSelect"),
      translationSelect: document.getElementById("translationSelect"),
      audioTranslationSelect: document.getElementById("audioTranslationSelect"),
      sessionModeSelect: document.getElementById("sessionModeSelect"),
      dualPageToggle: document.getElementById("dualPageToggle"),
      pageInput: document.getElementById("pageInput"),
      goPageBtn: document.getElementById("goPageBtn"),
      translationToggle: document.getElementById("translationToggle"),
      tajweedToggle: document.getElementById("tajweedToggle"),
      continueQueueToggle: document.getElementById("continueQueueToggle"),
      pageLoopToggle: document.getElementById("pageLoopToggle"),
      repeatCountSelect: document.getElementById("repeatCountSelect"),
      speedSelect: document.getElementById("speedSelect"),
      rangeRepeatToggle: document.getElementById("rangeRepeatToggle"),
      rangeStartInput: document.getElementById("rangeStartInput"),
      rangeEndInput: document.getElementById("rangeEndInput"),
      dailyGoalInput: document.getElementById("dailyGoalInput"),
      progressStats: document.getElementById("progressStats"),
      bookmarkList: document.getElementById("bookmarkList"),
      clearBookmarksBtn: document.getElementById("clearBookmarksBtn"),
      surahList: document.getElementById("surahList"),
      pageTitle: document.getElementById("pageTitle"),
      pageMeta: document.getElementById("pageMeta"),
      prevPageBtn: document.getElementById("prevPageBtn"),
      nextPageBtn: document.getElementById("nextPageBtn"),
      playPageBtn: document.getElementById("playPageBtn"),
      globalPlayPauseBtn: document.getElementById("globalPlayPauseBtn"),
      practiceRecordBtn: document.getElementById("practiceRecordBtn"),
      practicePlayBtn: document.getElementById("practicePlayBtn"),
      nowPlaying: document.getElementById("nowPlaying"),
      practiceStatus: document.getElementById("practiceStatus"),
      loadingIndicator: document.getElementById("loadingIndicator"),
      loadingText: document.getElementById("loadingText"),
      errorBanner: document.getElementById("errorBanner"),
      bookSpread: document.getElementById("bookSpread"),
      mainPageBadge: document.getElementById("mainPageBadge"),
      secondaryPageCard: document.getElementById("secondaryPageCard"),
      secondaryPageBadge: document.getElementById("secondaryPageBadge"),
      ayahContainer: document.getElementById("ayahContainer"),
      ayahContainerSecondary: document.getElementById("ayahContainerSecondary"),
      playerBar: document.getElementById("playerBar"),
      wordTooltip: document.getElementById("wordTooltip"),
      audio: document.getElementById("globalAudio"),
      practiceAudio: document.getElementById("practiceAudio")
    };

    function safeLocalStorageGet(key, fallbackValue) {
      try {
        const value = localStorage.getItem(key);
        return value === null ? fallbackValue : value;
      } catch {
        return fallbackValue;
      }
    }

    function safeLocalStorageSet(key, value) {
      try {
        localStorage.setItem(key, value);
      } catch {
        // Ignore storage errors.
      }
    }

    function safeLocalStorageGetJson(key, fallbackValue) {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return fallbackValue;
        const parsed = JSON.parse(raw);
        return parsed ?? fallbackValue;
      } catch {
        return fallbackValue;
      }
    }

    function safeLocalStorageSetJson(key, value) {
      try {
        localStorage.setItem(key, JSON.stringify(value));
      } catch {
        // Ignore storage errors.
      }
    }

    function escapeHtml(value) {
      return String(value)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function clamp(value, min, max) {
      if (!Number.isFinite(value)) return min;
      return Math.max(min, Math.min(max, Math.trunc(value)));
    }

    function clampPage(value) {
      return clamp(value, 1, TOTAL_PAGES);
    }

    function pageStep() {
      return state.dualPageEnabled ? 2 : 1;
    }

    function maxPrimaryPageForMode() {
      return state.dualPageEnabled ? TOTAL_PAGES - 1 : TOTAL_PAGES;
    }

    function normalizePageForMode(pageValue) {
      let page = clampPage(pageValue);
      if (state.dualPageEnabled) {
        if (page > TOTAL_PAGES - 1) page = TOTAL_PAGES - 1;
        if (page % 2 === 0) page -= 1;
      }
      return clampPage(page);
    }

    function setLoading(isLoading, text = "Loading...") {
      els.loadingText.textContent = text;
      els.loadingIndicator.classList.toggle("hidden", !isLoading);
    }

    function clearError() {
      els.errorBanner.textContent = "";
      els.errorBanner.classList.add("hidden");
    }

    function showError(message) {
      els.errorBanner.textContent = message;
      els.errorBanner.classList.remove("hidden");
    }

    function updatePlayerText(text) {
      els.nowPlaying.textContent = text;
      els.playerBar.textContent = text;
    }

    function todayKey() {
      return new Date().toISOString().slice(0, 10);
    }

    function yesterdayKey() {
      const date = new Date();
      date.setDate(date.getDate() - 1);
      return date.toISOString().slice(0, 10);
    }

    function persistSettings() {
      safeLocalStorageSetJson(STORAGE_KEYS.settings, {
        sessionMode: state.sessionMode,
        dualPageEnabled: state.dualPageEnabled,
        continueAcrossPages: state.continueAcrossPages,
        pageLoop: state.pageLoop,
        rangeRepeatEnabled: state.rangeRepeatEnabled,
        rangeStart: state.rangeStart,
        rangeEnd: state.rangeEnd,
        repeatAyahCount: state.repeatAyahCount,
        playbackRate: state.playbackRate,
        audioTranslation: state.currentAudioTranslation,
        tajweedMode: state.tajweedMode,
        translationVisible: state.translationVisible,
        dailyGoal: state.dailyGoal
      });
    }

    function loadPersistedState() {
      const savedSettings = safeLocalStorageGetJson(STORAGE_KEYS.settings, {});
      state.currentPage = clampPage(Number(safeLocalStorageGet(STORAGE_KEYS.lastPage, "1")));
      state.currentReciter = safeLocalStorageGet(STORAGE_KEYS.reciter, RECITERS[0].id);
      state.currentTranslation = safeLocalStorageGet(STORAGE_KEYS.translation, TRANSLATIONS[0].id);
      state.sessionMode = SESSION_MODES.some((mode) => mode.id === savedSettings.sessionMode)
        ? savedSettings.sessionMode
        : SESSION_MODES[0].id;
      state.dualPageEnabled = !!savedSettings.dualPageEnabled;
      state.continueAcrossPages = !!savedSettings.continueAcrossPages;
      state.pageLoop = !!savedSettings.pageLoop;
      state.rangeRepeatEnabled = !!savedSettings.rangeRepeatEnabled;
      state.rangeStart = clamp(Number(savedSettings.rangeStart || 1), 1, 999);
      state.rangeEnd = clamp(Number(savedSettings.rangeEnd || 1), 1, 999);
      state.repeatAyahCount = REPEAT_OPTIONS.includes(Number(savedSettings.repeatAyahCount))
        ? Number(savedSettings.repeatAyahCount)
        : 1;
      state.playbackRate = SPEED_OPTIONS.includes(Number(savedSettings.playbackRate))
        ? Number(savedSettings.playbackRate)
        : 1;
      state.currentAudioTranslation = AUDIO_TRANSLATIONS.some((item) => item.id === savedSettings.audioTranslation)
        ? savedSettings.audioTranslation
        : AUDIO_TRANSLATIONS[0].id;
      state.tajweedMode = !!savedSettings.tajweedMode;
      state.translationVisible = savedSettings.translationVisible !== false;
      state.dailyGoal = clamp(Number(savedSettings.dailyGoal || 5), 1, 50);
      state.bookmarks = safeLocalStorageGetJson(STORAGE_KEYS.bookmarks, []);
      if (!Array.isArray(state.bookmarks)) state.bookmarks = [];
      state.bookmarks = state.bookmarks
        .map((bookmark) => ({
          ...bookmark,
          number: Number(bookmark.number),
          page: clampPage(Number(bookmark.page || 1)),
          numberInSurah: Number(bookmark.numberInSurah || 0),
          surahNumber: Number(bookmark.surahNumber || 0),
          surahEnglish: String(bookmark.surahEnglish || ""),
          note: String(bookmark.note || "")
        }))
        .filter((bookmark) => Number.isFinite(bookmark.number));
      state.progress = safeLocalStorageGetJson(STORAGE_KEYS.progress, state.progress);
      if (!Array.isArray(state.progress.completedPages)) state.progress.completedPages = [];
      state.progress.completedPages = [...new Set(
        state.progress.completedPages
          .map((value) => Number(value))
          .filter((value) => Number.isFinite(value))
          .map((value) => clampPage(value))
      )];
      if (!state.progress.pageHistory || typeof state.progress.pageHistory !== "object") state.progress.pageHistory = {};
      Object.keys(state.progress.pageHistory).forEach((dateKey) => {
        const values = Array.isArray(state.progress.pageHistory[dateKey]) ? state.progress.pageHistory[dateKey] : [];
        state.progress.pageHistory[dateKey] = [...new Set(
          values
            .map((value) => Number(value))
            .filter((value) => Number.isFinite(value))
            .map((value) => clampPage(value))
        )];
      });
      if (!Number.isFinite(state.progress.streak)) state.progress.streak = 0;
      if (typeof state.progress.lastActiveDate !== "string") state.progress.lastActiveDate = "";
      if (!RECITERS.some((reciter) => reciter.id === state.currentReciter)) state.currentReciter = RECITERS[0].id;
      if (!TRANSLATIONS.some((edition) => edition.id === state.currentTranslation)) state.currentTranslation = TRANSLATIONS[0].id;
      state.currentPage = normalizePageForMode(state.currentPage);
    }

    function persistProgress() {
      safeLocalStorageSetJson(STORAGE_KEYS.progress, state.progress);
    }

    function persistBookmarks() {
      safeLocalStorageSetJson(STORAGE_KEYS.bookmarks, state.bookmarks);
    }

    function updateButtons() {
      const hasAyahs = state.ayahs.length > 0;
      const hasPlayableAyahs = hasAyahs && state.ayahs.some((ayah) => !!ayah.audioUrl);
      els.prevPageBtn.disabled = state.currentPage <= 1;
      els.nextPageBtn.disabled = state.currentPage >= maxPrimaryPageForMode();
      els.playPageBtn.disabled = !hasPlayableAyahs;
      els.globalPlayPauseBtn.disabled = !hasPlayableAyahs;
      els.globalPlayPauseBtn.textContent = els.audio.paused ? "Play" : "Pause";
      els.playPageBtn.textContent = state.isFullPageMode ? "Stop Full Page" : "Play Full Page";
      els.rangeStartInput.disabled = !state.rangeRepeatEnabled;
      els.rangeEndInput.disabled = !state.rangeRepeatEnabled;
      const currentAyah = state.ayahs[state.currentAyahIndex] || null;
      const hasPractice = !!(currentAyah && state.practiceRecordings[currentAyah.number]);
      els.practiceRecordBtn.disabled = (!currentAyah && !state.practiceIsRecording) || (!hasAyahs && !state.practiceIsRecording);
      els.practiceRecordBtn.textContent = state.practiceIsRecording ? "Stop Practice" : "Start Practice";
      els.practicePlayBtn.disabled = !hasPractice || state.practiceIsRecording;
    }

    function updateSpreadLayout() {
      const showDual = state.dualPageEnabled && state.secondaryAyahs.length > 0 && !!state.secondaryPage;
      els.secondaryPageCard.classList.toggle("hidden", !showDual);
      els.bookSpread.classList.toggle("dual", showDual);
      els.mainPageBadge.textContent = showDual
        ? `Spread Left: Page ${state.currentPage}`
        : `Page ${state.currentPage}`;
      if (showDual) {
        els.secondaryPageBadge.textContent = `Spread Right: Page ${state.secondaryPage}`;
      }
    }

    function applySessionMode(modeId, options = {}) {
      const mode = SESSION_MODES.some((modeItem) => modeItem.id === modeId) ? modeId : SESSION_MODES[0].id;
      state.sessionMode = mode;
      if (mode === "read") {
        state.translationVisible = true;
        state.tajweedMode = false;
        state.currentAudioTranslation = "none";
        state.repeatAyahCount = 1;
        state.playbackRate = 1;
        state.continueAcrossPages = false;
        state.pageLoop = false;
        state.rangeRepeatEnabled = false;
      } else if (mode === "listen") {
        state.translationVisible = true;
        state.tajweedMode = false;
        state.currentAudioTranslation = "none";
        state.repeatAyahCount = 1;
        state.playbackRate = 1;
        state.continueAcrossPages = true;
        state.pageLoop = false;
        state.rangeRepeatEnabled = false;
      } else if (mode === "memorize") {
        state.translationVisible = false;
        state.tajweedMode = true;
        state.currentAudioTranslation = "none";
        state.repeatAyahCount = 3;
        state.playbackRate = 0.75;
        state.continueAcrossPages = false;
        state.pageLoop = false;
        state.rangeRepeatEnabled = false;
      } else if (mode === "reflect") {
        state.translationVisible = true;
        state.tajweedMode = false;
        state.currentAudioTranslation = "en.walk";
        state.repeatAyahCount = 1;
        state.playbackRate = 0.75;
        state.continueAcrossPages = false;
        state.pageLoop = false;
        state.rangeRepeatEnabled = false;
      }

      state.currentAyahRepeatLeft = Math.max(1, state.repeatAyahCount);
      if (options.syncUi !== false) {
        els.sessionModeSelect.value = state.sessionMode;
        els.translationToggle.checked = state.translationVisible;
        els.tajweedToggle.checked = state.tajweedMode;
        els.audioTranslationSelect.value = state.currentAudioTranslation;
        els.repeatCountSelect.value = String(state.repeatAyahCount);
        els.speedSelect.value = String(state.playbackRate);
        els.continueQueueToggle.checked = state.continueAcrossPages;
        els.rangeRepeatToggle.checked = state.rangeRepeatEnabled;
      }
      document.body.classList.toggle("translation-off", !state.translationVisible);
      els.audio.playbackRate = state.playbackRate;
      if (options.persist !== false) persistSettings();
      updateButtons();
    }

    async function fetchJson(path) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000);
      try {
        const response = await fetch(`${API_BASE}${path}`, { signal: controller.signal });
        const payload = await response.json().catch(() => null);
        if (!response.ok || !payload || payload.status !== "OK") {
          const reason = payload && payload.data ? String(payload.data) : `Request failed (${response.status})`;
          throw new Error(reason);
        }
        return payload.data;
      } catch (error) {
        if (error.name === "AbortError") {
          throw new Error("Request timed out. Please check your internet connection.");
        }
        throw error;
      } finally {
        clearTimeout(timeoutId);
      }
    }

    async function loadSurahList() {
      setLoading(true, "Loading Surah list...");
      clearError();
      try {
        state.surahs = await fetchJson("/surah");
        renderSurahList();
      } catch (error) {
        showError(`Could not load Surah list: ${error.message}`);
      } finally {
        setLoading(false);
      }
    }

    function getCurrentPageSurahNumbers() {
      const combined = [...state.ayahs];
      if (state.dualPageEnabled && state.secondaryAyahs.length) combined.push(...state.secondaryAyahs);
      return new Set(combined.map((ayah) => ayah.surah.number));
    }

    function renderSurahList() {
      const q = state.searchTerm.trim().toLowerCase();
      const activeSurahSet = getCurrentPageSurahNumbers();
      const filtered = state.surahs.filter((surah) => {
        if (!q) return true;
        return (
          surah.englishName.toLowerCase().includes(q) ||
          surah.name.toLowerCase().includes(q) ||
          surah.englishNameTranslation.toLowerCase().includes(q) ||
          String(surah.number).includes(q)
        );
      });

      if (!filtered.length) {
        els.surahList.innerHTML = '<li class="empty-state">No Surah matches your search.</li>';
        return;
      }

      els.surahList.innerHTML = filtered.map((surah) => {
        const activeClass = activeSurahSet.has(surah.number) ? "active" : "";
        return `
          <li>
            <button class="surah-btn ${activeClass}" data-surah="${surah.number}">
              <span class="surah-title">${surah.number}. ${escapeHtml(surah.englishName)} - ${escapeHtml(surah.name)}</span>
              <span class="surah-sub">${escapeHtml(surah.englishNameTranslation)} | ${surah.numberOfAyahs} Ayahs</span>
            </button>
          </li>
        `;
      }).join("");
    }

    function normalizeArabicWord(word) {
      return String(word)
        .replace(/[\u064B-\u065F\u0670\u06D6-\u06ED]/g, "")
        .replace(/[^\u0621-\u064A]/g, "");
    }

    function transliterateWord(word) {
      const normalized = normalizeArabicWord(word);
      if (!normalized) return "-";
      let out = "";
      for (const char of normalized) out += TRANSLIT_MAP[char] || char;
      return out;
    }

    function meaningForWord(word) {
      const normalized = normalizeArabicWord(word);
      return WORD_MEANINGS[normalized] || "Meaning not in quick dictionary.";
    }

    function tajweedWrapWord(word) {
      const clean = normalizeArabicWord(word);
      if (!state.tajweedMode) return escapeHtml(word);
      if (clean.includes("الله")) return `<span class="tajweed-lafz">${escapeHtml(word)}</span>`;
      let result = "";
      for (const char of String(word)) {
        let className = "";
        if (/[نم]/.test(char)) className = "tajweed-ghunnah";
        else if (/[اويى]/.test(char)) className = "tajweed-madd";
        else if (/[قطبجد]/.test(char)) className = "tajweed-qalqalah";
        result += className
          ? `<span class="tajweed-letter ${className}">${escapeHtml(char)}</span>`
          : escapeHtml(char);
      }
      return result;
    }

    function renderArabicText(text) {
      const tokens = String(text || "").trim().split(/\s+/).filter(Boolean);
      return tokens.map((token, tokenIndex) => (
        `<span class="word-chip" data-word-index="${tokenIndex}" data-word="${encodeURIComponent(token)}">${tajweedWrapWord(token)}</span>`
      )).join(" ");
    }

    function getWordChipsForAyah(index) {
      if (index < 0) return [];
      const ayahCard = els.ayahContainer.querySelector(`.ayah-card[data-ayah-index="${index}"]`);
      if (!ayahCard) return [];
      return Array.from(ayahCard.querySelectorAll(".word-chip"));
    }

    function clearWordCursor(index = null) {
      const chips = index === null
        ? Array.from(document.querySelectorAll("#ayahContainer .word-chip, #ayahContainerSecondary .word-chip"))
        : getWordChipsForAyah(index);
      chips.forEach((chip) => {
        chip.classList.remove("cursor-read", "cursor-active");
      });
    }

    function setWordCursorCompletedForCurrentAyah() {
      const chips = getWordChipsForAyah(state.currentAyahIndex);
      if (!chips.length) return;
      chips.forEach((chip) => {
        chip.classList.remove("cursor-active");
        chip.classList.add("cursor-read");
      });
    }

    function updateWordCursorForCurrentAyah() {
      if (state.currentAyahIndex < 0) return;
      if (state.currentPlaybackPhase !== "arabic") return;
      const chips = getWordChipsForAyah(state.currentAyahIndex);
      if (!chips.length) return;
      const duration = Number(els.audio.duration);
      const currentTime = Number(els.audio.currentTime);
      const safeDuration = Number.isFinite(duration) && duration > 0 ? duration : 0;
      const rawProgress = safeDuration ? currentTime / safeDuration : 0;
      const clampedProgress = Math.max(0, Math.min(0.9999, rawProgress));
      const cursorIndex = Math.max(0, Math.min(chips.length - 1, Math.floor(clampedProgress * chips.length)));

      chips.forEach((chip, chipIndex) => {
        chip.classList.toggle("cursor-read", chipIndex < cursorIndex);
        chip.classList.toggle("cursor-active", chipIndex === cursorIndex);
      });
    }

    function isBookmarked(ayahNumber) {
      return state.bookmarks.some((bookmark) => bookmark.number === ayahNumber);
    }

    function renderAyahs() {
      if (!state.ayahs.length) {
        els.ayahContainer.innerHTML = '<div class="empty-state">No page content available.</div>';
        els.mainPageBadge.textContent = "Page";
        return;
      }

      let html = "";
      let previousSurahNumber = null;
      for (let i = 0; i < state.ayahs.length; i += 1) {
        const ayah = state.ayahs[i];
        const bookmarked = isBookmarked(ayah.number);
        if (ayah.surah.number !== previousSurahNumber) {
          html += `<div class="surah-divider">${escapeHtml(ayah.surah.englishName)} - ${escapeHtml(ayah.surah.name)}</div>`;
          previousSurahNumber = ayah.surah.number;
        }
        html += `
          <article class="ayah-card" data-ayah-index="${i}">
            <div class="ayah-header">
              <span class="ayah-number">Ayah ${ayah.numberInSurah} (PagePos ${i + 1})</span>
              <div class="ayah-actions">
                <button class="ayah-btn ayah-play-btn" data-ayah-index="${i}">Play</button>
                <button class="ayah-btn ayah-bookmark-btn ${bookmarked ? "saved" : ""}" data-ayah-index="${i}">
                  ${bookmarked ? "Saved" : "Bookmark"}
                </button>
                <button class="ayah-btn ayah-note-btn" data-ayah-index="${i}">Note</button>
              </div>
            </div>
            <p class="arabic-text" lang="ar" dir="rtl">${renderArabicText(ayah.arabicText)}</p>
            <p class="translation-text">${escapeHtml(ayah.translationText || "")}</p>
          </article>
        `;
      }
      els.ayahContainer.innerHTML = html;
      els.mainPageBadge.textContent = `Page ${state.currentPage}`;
      updateAyahButtons();
    }

    function renderSecondaryAyahs() {
      if (!state.dualPageEnabled || !state.secondaryAyahs.length || !state.secondaryPage) {
        els.ayahContainerSecondary.innerHTML = "";
        return;
      }

      let html = "";
      let previousSurahNumber = null;
      for (let i = 0; i < state.secondaryAyahs.length; i += 1) {
        const ayah = state.secondaryAyahs[i];
        if (ayah.surah.number !== previousSurahNumber) {
          html += `<div class="surah-divider">${escapeHtml(ayah.surah.englishName)} - ${escapeHtml(ayah.surah.name)}</div>`;
          previousSurahNumber = ayah.surah.number;
        }
        html += `
          <article class="ayah-card">
            <div class="ayah-header">
              <span class="ayah-number">Ayah ${ayah.numberInSurah}</span>
            </div>
            <p class="arabic-text" lang="ar" dir="rtl">${renderArabicText(ayah.arabicText)}</p>
            <p class="translation-text">${escapeHtml(ayah.translationText || "")}</p>
          </article>
        `;
      }
      els.ayahContainerSecondary.innerHTML = html;
      els.secondaryPageBadge.textContent = `Page ${state.secondaryPage}`;
    }

    function highlightAyah(index) {
      const previousActive = els.ayahContainer.querySelector(".ayah-card.active");
      if (previousActive) previousActive.classList.remove("active");
      if (index < 0) return;
      const target = els.ayahContainer.querySelector(`.ayah-card[data-ayah-index="${index}"]`);
      if (!target) return;
      target.classList.add("active");
      target.scrollIntoView({ behavior: "smooth", block: "center" });
    }

    function updateAyahButtons() {
      const playButtons = els.ayahContainer.querySelectorAll(".ayah-play-btn[data-ayah-index]");
      playButtons.forEach((button) => {
        const index = Number(button.dataset.ayahIndex);
        const ayah = state.ayahs[index];
        const hasAudio = !!(ayah && ayah.audioUrl);
        const isCurrent = index === state.currentAyahIndex;
        const isPlaying = isCurrent && !els.audio.paused;
        button.textContent = hasAudio ? (isPlaying ? "Pause" : "Play") : "No Audio";
        button.disabled = !hasAudio;
        button.classList.toggle("is-playing", isPlaying);
      });

      const bookmarkButtons = els.ayahContainer.querySelectorAll(".ayah-bookmark-btn[data-ayah-index]");
      bookmarkButtons.forEach((button) => {
        const index = Number(button.dataset.ayahIndex);
        const ayah = state.ayahs[index];
        if (!ayah) return;
        const saved = isBookmarked(ayah.number);
        button.textContent = saved ? "Saved" : "Bookmark";
        button.classList.toggle("saved", saved);
      });
    }

    function updatePageHeader() {
      const isSpread = state.dualPageEnabled && state.secondaryPage;
      els.pageTitle.textContent = isSpread
        ? `Mushaf Spread ${state.currentPage}-${state.secondaryPage} / ${TOTAL_PAGES}`
        : `Mushaf Page ${state.currentPage} / ${TOTAL_PAGES}`;
      els.pageInput.value = String(state.currentPage);
      if (!state.ayahs.length) {
        els.pageMeta.textContent = "No page metadata available.";
        return;
      }
      const combinedAyahs = [...state.ayahs, ...(state.secondaryAyahs || [])];
      const unique = [];
      const seen = new Set();
      combinedAyahs.forEach((ayah) => {
        if (!seen.has(ayah.surah.number)) {
          seen.add(ayah.surah.number);
          unique.push(`${ayah.surah.englishName} (${ayah.surah.name})`);
        }
      });
      const translationLabel = TRANSLATIONS.find((item) => item.id === state.currentTranslation)?.label || state.currentTranslation;
      const audioTranslationLabel = AUDIO_TRANSLATIONS.find((item) => item.id === state.currentAudioTranslation)?.label || state.currentAudioTranslation;
      els.pageMeta.textContent = `${unique.join(" | ")} | ${combinedAyahs.length} Ayahs visible | Translation: ${translationLabel} | ${audioTranslationLabel}`;
    }

    async function getSurahStartPage(surahNumber) {
      if (state.surahStartPageCache[surahNumber]) return state.surahStartPageCache[surahNumber];
      const data = await fetchJson(`/ayah/${surahNumber}:1/quran-uthmani`);
      state.surahStartPageCache[surahNumber] = data.page;
      return data.page;
    }

    function updateRangeBounds() {
      const max = Math.max(1, state.ayahs.length || 1);
      state.rangeStart = clamp(state.rangeStart, 1, max);
      state.rangeEnd = clamp(state.rangeEnd, 1, max);
      if (state.rangeStart > state.rangeEnd) {
        const temp = state.rangeStart;
        state.rangeStart = state.rangeEnd;
        state.rangeEnd = temp;
      }
      els.rangeStartInput.max = String(max);
      els.rangeEndInput.max = String(max);
      els.rangeStartInput.value = String(state.rangeStart);
      els.rangeEndInput.value = String(state.rangeEnd);
    }

    function getRangeBoundIndexes() {
      if (!state.rangeRepeatEnabled || !state.ayahs.length) {
        return { enabled: false, start: 0, end: Math.max(0, state.ayahs.length - 1) };
      }
      const max = state.ayahs.length;
      let start = clamp(state.rangeStart, 1, max) - 1;
      let end = clamp(state.rangeEnd, 1, max) - 1;
      if (start > end) {
        const swap = start;
        start = end;
        end = swap;
      }
      return { enabled: true, start, end };
    }

    function markProgressForPage(pageNumber) {
      const page = clampPage(pageNumber);
      if (!state.progress.completedPages.includes(page)) state.progress.completedPages.push(page);
      const today = todayKey();
      if (!Array.isArray(state.progress.pageHistory[today])) state.progress.pageHistory[today] = [];
      if (!state.progress.pageHistory[today].includes(page)) state.progress.pageHistory[today].push(page);

      if (state.progress.lastActiveDate !== today) {
        state.progress.streak = state.progress.lastActiveDate === yesterdayKey()
          ? Math.max(1, state.progress.streak + 1)
          : 1;
        state.progress.lastActiveDate = today;
      }
      persistProgress();
      renderProgress();
    }

    function renderProgress() {
      const completed = state.progress.completedPages.length;
      const percent = ((completed / TOTAL_PAGES) * 100).toFixed(1);
      const today = todayKey();
      const todayCount = (state.progress.pageHistory[today] || []).length;
      const goalDone = todayCount >= state.dailyGoal ? "Goal reached" : "Goal in progress";
      els.progressStats.innerHTML = `
        <div class="progress-stats">
          <span>Completed pages: ${completed}/${TOTAL_PAGES} (${percent}%)</span>
          <span>Today: ${todayCount}/${state.dailyGoal} pages (${goalDone})</span>
          <span>Streak: ${state.progress.streak || 0} day(s)</span>
        </div>
      `;
    }

    function renderBookmarks() {
      if (!state.bookmarks.length) {
        els.bookmarkList.innerHTML = '<li class="empty-state">No bookmarks yet.</li>';
        return;
      }
      const sorted = [...state.bookmarks].sort((a, b) => a.number - b.number);
      els.bookmarkList.innerHTML = sorted.map((bookmark) => {
        const surahName = bookmark.surahEnglish || `Surah ${bookmark.surahNumber || "?"}`;
        const ayahNum = bookmark.numberInSurah || "?";
        const page = bookmark.page || "?";
        return `
        <li class="bookmark-item">
          <span>${escapeHtml(surahName)} ${ayahNum} (Page ${page})</span>
          <span>${bookmark.note ? escapeHtml(bookmark.note) : "No note"}</span>
          <div>
            <button data-action="jump" data-page="${page}" data-ayah="${bookmark.number}">Open</button>
            <button data-action="note" data-ayah="${bookmark.number}">Note</button>
            <button data-action="remove" data-ayah="${bookmark.number}">Remove</button>
          </div>
        </li>
      `;
      }).join("");
    }

    function bookmarkFromAyah(ayah, note = "") {
      return {
        number: ayah.number,
        page: ayah.page || state.currentPage,
        surahNumber: ayah.surah.number,
        surahEnglish: ayah.surah.englishName,
        numberInSurah: ayah.numberInSurah,
        note
      };
    }

    function toggleBookmark(index) {
      const ayah = state.ayahs[index];
      if (!ayah) return;
      const bookmarkIndex = state.bookmarks.findIndex((bookmark) => bookmark.number === ayah.number);
      if (bookmarkIndex >= 0) state.bookmarks.splice(bookmarkIndex, 1);
      else state.bookmarks.push(bookmarkFromAyah(ayah));
      persistBookmarks();
      renderBookmarks();
      updateAyahButtons();
    }

    function updateAyahNote(index) {
      const ayah = state.ayahs[index];
      if (!ayah) return;
      const bookmarkIndex = state.bookmarks.findIndex((bookmark) => bookmark.number === ayah.number);
      const existing = bookmarkIndex >= 0 ? state.bookmarks[bookmarkIndex].note || "" : "";
      const note = window.prompt("Add a note for this ayah:", existing);
      if (note === null) return;
      if (bookmarkIndex >= 0) state.bookmarks[bookmarkIndex].note = note.trim();
      else state.bookmarks.push(bookmarkFromAyah(ayah, note.trim()));
      persistBookmarks();
      renderBookmarks();
      updateAyahButtons();
    }

    function showWordTooltip(word, rect) {
      const translit = transliterateWord(word);
      const meaning = meaningForWord(word);
      els.wordTooltip.innerHTML = `
        <div class="raw-word">${escapeHtml(word)}</div>
        <div class="meta">Translit: ${escapeHtml(translit)}</div>
        <div class="meta">Meaning: ${escapeHtml(meaning)}</div>
      `;
      const x = Math.min(window.innerWidth - 255, Math.max(12, rect.left + (rect.width / 2) - 115));
      const y = Math.max(12, rect.top - 92);
      els.wordTooltip.style.left = `${x}px`;
      els.wordTooltip.style.top = `${y}px`;
      els.wordTooltip.classList.remove("hidden");
    }

    function hideWordTooltip() {
      els.wordTooltip.classList.add("hidden");
    }

    function stopPlaybackState(resetMode = true) {
      els.audio.pause();
      els.audio.removeAttribute("src");
      state.currentAyahIndex = -1;
      state.currentAyahRepeatLeft = Math.max(1, state.repeatAyahCount);
      state.currentPlaybackPhase = "arabic";
      clearWordCursor();
      if (resetMode) state.isFullPageMode = false;
      updatePlayerText("Not playing");
      updateAyahButtons();
      updateButtons();
    }

    function translationAudioLabel() {
      return AUDIO_TRANSLATIONS.find((item) => item.id === state.currentAudioTranslation)?.label || state.currentAudioTranslation;
    }

    function canPlaySelectedTranslationAudio(ayah) {
      return state.currentAudioTranslation !== "none" && !!(ayah && ayah.translationAudioUrl);
    }

    async function playSelectedTranslationForCurrentAyah() {
      if (state.currentAyahIndex < 0 || state.currentAyahIndex >= state.ayahs.length) return false;
      const ayah = state.ayahs[state.currentAyahIndex];
      if (!canPlaySelectedTranslationAudio(ayah)) return false;
      setWordCursorCompletedForCurrentAyah();
      state.currentPlaybackPhase = "translation";
      els.audio.src = ayah.translationAudioUrl;
      els.audio.playbackRate = state.playbackRate;
      updatePlayerText(
        `Playing Page ${state.currentPage} | ${ayah.surah.englishName} ${ayah.numberInSurah} | ${translationAudioLabel()} | ${state.playbackRate}x`
      );
      try {
        await els.audio.play();
        return true;
      } catch {
        state.currentPlaybackPhase = "arabic";
        showError("Could not start translation audio. Continuing with recitation only.");
        return false;
      }
    }

    async function loadPage(pageNumber, options = {}) {
      const targetPage = normalizePageForMode(pageNumber);
      setLoading(true, `Loading page ${targetPage}...`);
      clearError();
      stopPlaybackState(!options.preserveMode);
      state.currentPage = targetPage;
      safeLocalStorageSet(STORAGE_KEYS.lastPage, String(targetPage));

      try {
        const shouldLoadSecondary = state.dualPageEnabled && targetPage < TOTAL_PAGES;
        const secondaryPage = shouldLoadSecondary ? targetPage + 1 : null;
        const translationAudioPromise = state.currentAudioTranslation === "none"
          ? Promise.resolve(null)
          : fetchJson(`/page/${targetPage}/${state.currentAudioTranslation}`).catch(() => null);
        const secondaryArabicPromise = shouldLoadSecondary
          ? fetchJson(`/page/${secondaryPage}/quran-uthmani`).catch(() => null)
          : Promise.resolve(null);
        const secondaryTranslationPromise = shouldLoadSecondary
          ? fetchJson(`/page/${secondaryPage}/${state.currentTranslation}`).catch(() => null)
          : Promise.resolve(null);

        const [arabicPage, translationPage, audioPage, translationAudioPage, secondaryArabicPage, secondaryTranslationPage] = await Promise.all([
          fetchJson(`/page/${targetPage}/quran-uthmani`),
          fetchJson(`/page/${targetPage}/${state.currentTranslation}`),
          fetchJson(`/page/${targetPage}/${state.currentReciter}`),
          translationAudioPromise,
          secondaryArabicPromise,
          secondaryTranslationPromise
        ]);

        const translationByAyah = new Map((translationPage.ayahs || []).map((ayah) => [ayah.number, ayah.text]));
        const audioByAyah = new Map((audioPage.ayahs || []).map((ayah) => [ayah.number, ayah]));
        const translationAudioByAyah = new Map(
          ((translationAudioPage && translationAudioPage.ayahs) || []).map((ayah) => [
            ayah.number,
            ayah.audio || (ayah.audioSecondary && ayah.audioSecondary[0]) || ""
          ])
        );
        state.ayahs = (arabicPage.ayahs || []).map((ayah) => {
          const audioAyah = audioByAyah.get(ayah.number);
          return {
            number: ayah.number,
            numberInSurah: ayah.numberInSurah,
            surah: ayah.surah,
            page: ayah.page,
            arabicText: ayah.text,
            translationText: translationByAyah.get(ayah.number) || "",
            audioUrl: (audioAyah && (audioAyah.audio || (audioAyah.audioSecondary && audioAyah.audioSecondary[0]))) || "",
            translationAudioUrl: translationAudioByAyah.get(ayah.number) || ""
          };
        });
        state.secondaryPage = secondaryPage;
        if (shouldLoadSecondary && secondaryArabicPage && secondaryTranslationPage) {
          const secondaryTranslationByAyah = new Map(
            (secondaryTranslationPage.ayahs || []).map((ayah) => [ayah.number, ayah.text])
          );
          state.secondaryAyahs = (secondaryArabicPage.ayahs || []).map((ayah) => ({
            number: ayah.number,
            numberInSurah: ayah.numberInSurah,
            surah: ayah.surah,
            page: ayah.page,
            arabicText: ayah.text,
            translationText: secondaryTranslationByAyah.get(ayah.number) || "",
            audioUrl: "",
            translationAudioUrl: ""
          }));
        } else {
          state.secondaryAyahs = [];
          state.secondaryPage = null;
        }
        const nonFatalWarnings = [];
        if (!state.ayahs.some((ayah) => !!ayah.audioUrl)) {
          nonFatalWarnings.push("Selected reciter has no audio stream in this API. Please choose another reciter.");
        }
        if (state.currentAudioTranslation !== "none" && !translationAudioPage) {
          nonFatalWarnings.push(`Could not load ${translationAudioLabel()} for this page.`);
        } else if (state.currentAudioTranslation !== "none" && !state.ayahs.some((ayah) => !!ayah.translationAudioUrl)) {
          nonFatalWarnings.push(`${translationAudioLabel()} has no verse audio on this page.`);
        }
        if (shouldLoadSecondary && (!secondaryArabicPage || !secondaryTranslationPage)) {
          nonFatalWarnings.push("Could not load the second page of this spread. Showing single page.");
        }
        if (nonFatalWarnings.length) showError(nonFatalWarnings.join(" "));

        updateRangeBounds();
        updatePageHeader();
        renderSurahList();
        renderAyahs();
        renderSecondaryAyahs();
        updateSpreadLayout();
        if (state.pendingHighlightAyahNumber) {
          const index = state.ayahs.findIndex((ayah) => ayah.number === state.pendingHighlightAyahNumber);
          state.pendingHighlightAyahNumber = null;
          if (index >= 0) {
            state.currentAyahIndex = index;
            highlightAyah(index);
          } else {
            highlightAyah(-1);
          }
        } else {
          highlightAyah(-1);
        }
        updateButtons();
        updateAyahButtons();
        markProgressForPage(targetPage);
      } catch (error) {
        state.ayahs = [];
        state.secondaryAyahs = [];
        state.secondaryPage = null;
        updatePageHeader();
        renderSurahList();
        renderAyahs();
        renderSecondaryAyahs();
        updateSpreadLayout();
        updateButtons();
        showError(`Could not load page ${targetPage}: ${error.message}`);
      } finally {
        setLoading(false);
      }
    }

    async function playAyah(index, fromFullPage = false, options = {}) {
      if (index < 0 || index >= state.ayahs.length) return;
      const ayah = state.ayahs[index];
      if (!ayah.audioUrl) {
        showError("Audio URL is unavailable for this Ayah and reciter.");
        return;
      }
      clearError();
      state.currentAyahIndex = index;
      state.isFullPageMode = fromFullPage;
      state.currentPlaybackPhase = "arabic";
      if (options.resetRepeatCounter !== false) state.currentAyahRepeatLeft = Math.max(1, state.repeatAyahCount);
      els.audio.src = ayah.audioUrl;
      els.audio.playbackRate = state.playbackRate;
      highlightAyah(index);
      clearWordCursor();
      updateWordCursorForCurrentAyah();
      updatePlayerText(
        `Playing Page ${state.currentPage} | ${ayah.surah.englishName} ${ayah.numberInSurah} | ${state.playbackRate}x`
      );
      try {
        await els.audio.play();
      } catch {
        state.isFullPageMode = false;
        showError("Playback could not start automatically. Press play again.");
      }
      updateButtons();
      updateAyahButtons();
    }

    async function handleAyahPlayButton(index) {
      if (index === state.currentAyahIndex) {
        state.isFullPageMode = false;
        if (els.audio.paused) {
          try {
            await els.audio.play();
          } catch {
            showError("Playback failed to start. Please try again.");
          }
        } else {
          els.audio.pause();
        }
        updateButtons();
        updateAyahButtons();
        return;
      }
      await playAyah(index, false);
    }

    async function toggleGlobalPlayPause() {
      if (!state.ayahs.length) return;
      if (state.currentAyahIndex === -1) {
        await playAyah(0, false);
        return;
      }
      if (els.audio.paused) {
        try {
          await els.audio.play();
        } catch {
          showError("Playback failed to start. Please try again.");
        }
      } else {
        els.audio.pause();
      }
      updateButtons();
      updateAyahButtons();
    }

    async function toggleFullPagePlayback() {
      if (!state.ayahs.length) return;
      if (state.isFullPageMode) {
        state.isFullPageMode = false;
        updateButtons();
        return;
      }
      const range = getRangeBoundIndexes();
      let startIndex = state.currentAyahIndex;
      if (startIndex < 0) startIndex = range.enabled ? range.start : 0;
      if (range.enabled && (startIndex < range.start || startIndex > range.end)) startIndex = range.start;
      state.isFullPageMode = true;
      await playAyah(startIndex, true);
    }

    async function playRelativeAyah(offset) {
      if (!state.ayahs.length) return;
      let target = state.currentAyahIndex;
      if (target === -1) target = offset >= 0 ? 0 : state.ayahs.length - 1;
      else target = clamp(target + offset, 0, state.ayahs.length - 1);
      state.isFullPageMode = false;
      await playAyah(target, false);
    }

    function currentAyahForPractice() {
      if (state.currentAyahIndex < 0 || state.currentAyahIndex >= state.ayahs.length) return null;
      return state.ayahs[state.currentAyahIndex];
    }

    async function getAudioDurationFromUrl(url) {
      return new Promise((resolve, reject) => {
        const audioEl = new Audio();
        const timeoutId = setTimeout(() => reject(new Error("Duration load timeout")), 12000);
        audioEl.preload = "metadata";
        audioEl.src = url;
        audioEl.onloadedmetadata = () => {
          clearTimeout(timeoutId);
          resolve(Number(audioEl.duration) || 0);
        };
        audioEl.onerror = () => {
          clearTimeout(timeoutId);
          reject(new Error("Could not read audio metadata"));
        };
      });
    }

    async function getReferenceDurationForAyah(ayah) {
      if (!ayah || !ayah.audioUrl) return null;
      if (Number.isFinite(state.ayahDurationCache[ayah.number])) return state.ayahDurationCache[ayah.number];
      try {
        const duration = await getAudioDurationFromUrl(ayah.audioUrl);
        state.ayahDurationCache[ayah.number] = duration;
        return duration;
      } catch {
        return null;
      }
    }

    async function getBlobDuration(blobUrl) {
      try {
        return await getAudioDurationFromUrl(blobUrl);
      } catch {
        return null;
      }
    }

    function updatePracticeStatus(text) {
      els.practiceStatus.textContent = text;
    }

    async function startPracticeRecording() {
      const ayah = currentAyahForPractice();
      if (!ayah) {
        showError("Select and play an ayah first, then start practice.");
        return;
      }
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showError("Microphone recording is not supported in this browser.");
        return;
      }
      if (typeof MediaRecorder === "undefined") {
        showError("MediaRecorder API is unavailable in this browser.");
        return;
      }
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const recorder = new MediaRecorder(stream);
        state.practiceStream = stream;
        state.practiceMediaRecorder = recorder;
        state.practiceChunks = [];
        state.practiceActiveAyahNumber = ayah.number;
        state.practiceRecordingStartMs = Date.now();
        state.practiceIsRecording = true;
        updateButtons();
        updatePracticeStatus(`Recording practice for ${ayah.surah.englishName} Ayah ${ayah.numberInSurah}...`);

        recorder.ondataavailable = (event) => {
          if (event.data && event.data.size > 0) state.practiceChunks.push(event.data);
        };

        recorder.onstop = async () => {
          state.practiceIsRecording = false;
          const blob = new Blob(state.practiceChunks, { type: recorder.mimeType || "audio/webm" });
          const url = URL.createObjectURL(blob);
          const old = state.practiceRecordings[ayah.number];
          if (old && old.url) URL.revokeObjectURL(old.url);
          const userDuration = await getBlobDuration(url) || ((Date.now() - state.practiceRecordingStartMs) / 1000);
          const referenceDuration = await getReferenceDurationForAyah(ayah);
          state.practiceRecordings[ayah.number] = {
            url,
            duration: userDuration,
            capturedAt: new Date().toISOString()
          };
          if (state.practiceStream) {
            state.practiceStream.getTracks().forEach((track) => track.stop());
          }
          state.practiceStream = null;
          state.practiceMediaRecorder = null;
          state.practiceChunks = [];
          state.practiceActiveAyahNumber = null;
          updateButtons();
          if (referenceDuration && referenceDuration > 0) {
            const ratio = ((userDuration / referenceDuration) * 100).toFixed(0);
            updatePracticeStatus(
              `Practice saved. Your duration: ${userDuration.toFixed(1)}s vs reciter: ${referenceDuration.toFixed(1)}s (${ratio}%).`
            );
          } else {
            updatePracticeStatus(`Practice saved. Your duration: ${userDuration.toFixed(1)}s.`);
          }
        };

        recorder.start();
      } catch (error) {
        state.practiceIsRecording = false;
        updateButtons();
        showError(`Microphone permission failed: ${error.message || "Unable to access microphone."}`);
      }
    }

    function stopPracticeRecording() {
      if (!state.practiceMediaRecorder || state.practiceMediaRecorder.state !== "recording") return;
      state.practiceMediaRecorder.stop();
    }

    async function togglePracticeRecording() {
      if (state.practiceIsRecording) {
        stopPracticeRecording();
      } else {
        await startPracticeRecording();
      }
    }

    async function playPracticeRecording() {
      const ayah = currentAyahForPractice();
      if (!ayah) {
        showError("Select an ayah first to play your recorded practice.");
        return;
      }
      const recording = state.practiceRecordings[ayah.number];
      if (!recording || !recording.url) {
        showError("No practice recording found for this ayah.");
        return;
      }
      try {
        els.practiceAudio.src = recording.url;
        await els.practiceAudio.play();
        updatePracticeStatus(`Playing your recitation for ${ayah.surah.englishName} Ayah ${ayah.numberInSurah}.`);
      } catch {
        showError("Could not play your recorded recitation.");
      }
    }

    async function reloadCurrentPagePreservingPosition() {
      const previousAyahNumber = state.currentAyahIndex >= 0 ? state.ayahs[state.currentAyahIndex].number : null;
      const wasPlaying = previousAyahNumber !== null && !els.audio.paused;
      const wasFullMode = state.isFullPageMode;
      await loadPage(state.currentPage);
      if (previousAyahNumber === null) return;
      const nextIndex = state.ayahs.findIndex((ayah) => ayah.number === previousAyahNumber);
      if (nextIndex === -1) return;
      state.currentAyahIndex = nextIndex;
      highlightAyah(nextIndex);
      updateAyahButtons();
      if (wasPlaying) await playAyah(nextIndex, wasFullMode);
    }

    async function handleReciterChange() {
      const selected = els.reciterSelect.value;
      if (selected === state.currentReciter) return;
      state.currentReciter = selected;
      safeLocalStorageSet(STORAGE_KEYS.reciter, selected);
      await reloadCurrentPagePreservingPosition();
    }

    async function handleTranslationEditionChange() {
      const selected = els.translationSelect.value;
      if (selected === state.currentTranslation) return;
      state.currentTranslation = selected;
      safeLocalStorageSet(STORAGE_KEYS.translation, selected);
      await reloadCurrentPagePreservingPosition();
    }

    async function handleAudioTranslationChange() {
      const selected = els.audioTranslationSelect.value;
      if (selected === state.currentAudioTranslation) return;
      state.currentAudioTranslation = selected;
      persistSettings();
      await reloadCurrentPagePreservingPosition();
    }

    async function setDualPageEnabled(enabled, options = {}) {
      const nextValue = !!enabled;
      if (state.dualPageEnabled === nextValue) return;
      state.dualPageEnabled = nextValue;
      els.dualPageToggle.checked = state.dualPageEnabled;
      if (nextValue) {
        state.currentPage = normalizePageForMode(state.currentPage);
      }
      persistSettings();
      if (options.reload !== false) {
        await loadPage(state.currentPage);
      } else {
        updateSpreadLayout();
      }
    }

    function initSelects() {
      els.reciterSelect.innerHTML = RECITERS.map(
        (item) => `<option value="${item.id}">${escapeHtml(item.label)} (${escapeHtml(item.id)})</option>`
      ).join("");
      els.translationSelect.innerHTML = TRANSLATIONS.map(
        (item) => `<option value="${item.id}">${escapeHtml(item.label)} (${escapeHtml(item.id)})</option>`
      ).join("");
      els.audioTranslationSelect.innerHTML = AUDIO_TRANSLATIONS.map(
        (item) => `<option value="${item.id}">${escapeHtml(item.label)}</option>`
      ).join("");
      els.sessionModeSelect.innerHTML = SESSION_MODES.map(
        (mode) => `<option value="${mode.id}">${escapeHtml(mode.label)}</option>`
      ).join("");
      els.repeatCountSelect.innerHTML = REPEAT_OPTIONS.map(
        (count) => `<option value="${count}">Repeat Ayah x${count}</option>`
      ).join("");
      els.speedSelect.innerHTML = SPEED_OPTIONS.map(
        (speed) => `<option value="${speed}">Speed ${speed}x</option>`
      ).join("");

      els.reciterSelect.value = state.currentReciter;
      els.translationSelect.value = state.currentTranslation;
      els.audioTranslationSelect.value = state.currentAudioTranslation;
      els.sessionModeSelect.value = state.sessionMode;
      els.dualPageToggle.checked = state.dualPageEnabled;
      els.repeatCountSelect.value = String(state.repeatAyahCount);
      els.speedSelect.value = String(state.playbackRate);
      els.translationToggle.checked = state.translationVisible;
      els.tajweedToggle.checked = state.tajweedMode;
      els.continueQueueToggle.checked = state.continueAcrossPages;
      els.pageLoopToggle.checked = state.pageLoop;
      els.rangeRepeatToggle.checked = state.rangeRepeatEnabled;
      els.dailyGoalInput.value = String(state.dailyGoal);
      document.body.classList.toggle("translation-off", !state.translationVisible);
      els.audio.playbackRate = state.playbackRate;
      applySessionMode(state.sessionMode, { persist: false, syncUi: true });
      updateButtons();
    }

    function bindEvents() {
      els.searchInput.addEventListener("input", () => {
        state.searchTerm = els.searchInput.value;
        renderSurahList();
      });

      els.translationToggle.addEventListener("change", () => {
        state.translationVisible = els.translationToggle.checked;
        document.body.classList.toggle("translation-off", !state.translationVisible);
        persistSettings();
      });

      els.tajweedToggle.addEventListener("change", () => {
        state.tajweedMode = els.tajweedToggle.checked;
        persistSettings();
        renderAyahs();
        renderSecondaryAyahs();
        updateSpreadLayout();
        highlightAyah(state.currentAyahIndex);
      });

      els.continueQueueToggle.addEventListener("change", () => {
        state.continueAcrossPages = els.continueQueueToggle.checked;
        persistSettings();
      });

      els.pageLoopToggle.addEventListener("change", () => {
        state.pageLoop = els.pageLoopToggle.checked;
        persistSettings();
      });

      els.rangeRepeatToggle.addEventListener("change", () => {
        state.rangeRepeatEnabled = els.rangeRepeatToggle.checked;
        updateButtons();
        persistSettings();
      });

      els.rangeStartInput.addEventListener("change", () => {
        state.rangeStart = clamp(Number(els.rangeStartInput.value), 1, Math.max(1, state.ayahs.length));
        updateRangeBounds();
        persistSettings();
      });

      els.rangeEndInput.addEventListener("change", () => {
        state.rangeEnd = clamp(Number(els.rangeEndInput.value), 1, Math.max(1, state.ayahs.length));
        updateRangeBounds();
        persistSettings();
      });

      els.repeatCountSelect.addEventListener("change", () => {
        state.repeatAyahCount = clamp(Number(els.repeatCountSelect.value), 1, 10);
        state.currentAyahRepeatLeft = Math.max(1, state.repeatAyahCount);
        persistSettings();
      });

      els.speedSelect.addEventListener("change", () => {
        state.playbackRate = Number(els.speedSelect.value);
        els.audio.playbackRate = state.playbackRate;
        persistSettings();
      });

      els.sessionModeSelect.addEventListener("change", async () => {
        applySessionMode(els.sessionModeSelect.value, { persist: true, syncUi: true });
        await reloadCurrentPagePreservingPosition();
      });

      els.dualPageToggle.addEventListener("change", async () => {
        await setDualPageEnabled(els.dualPageToggle.checked, { reload: true });
      });

      els.dailyGoalInput.addEventListener("change", () => {
        state.dailyGoal = clamp(Number(els.dailyGoalInput.value), 1, 50);
        els.dailyGoalInput.value = String(state.dailyGoal);
        persistSettings();
        renderProgress();
      });

      els.practiceRecordBtn.addEventListener("click", async () => {
        await togglePracticeRecording();
      });

      els.practicePlayBtn.addEventListener("click", async () => {
        await playPracticeRecording();
      });

      els.goPageBtn.addEventListener("click", () => {
        loadPage(Number(els.pageInput.value));
      });

      els.pageInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          loadPage(Number(els.pageInput.value));
        }
      });

      els.prevPageBtn.addEventListener("click", () => loadPage(state.currentPage - pageStep()));
      els.nextPageBtn.addEventListener("click", () => loadPage(state.currentPage + pageStep()));
      els.playPageBtn.addEventListener("click", toggleFullPagePlayback);
      els.globalPlayPauseBtn.addEventListener("click", toggleGlobalPlayPause);
      els.reciterSelect.addEventListener("change", handleReciterChange);
      els.translationSelect.addEventListener("change", handleTranslationEditionChange);
      els.audioTranslationSelect.addEventListener("change", handleAudioTranslationChange);

      els.clearBookmarksBtn.addEventListener("click", () => {
        if (!state.bookmarks.length) return;
        if (!window.confirm("Clear all bookmarks?")) return;
        state.bookmarks = [];
        persistBookmarks();
        renderBookmarks();
        updateAyahButtons();
      });

      els.bookmarkList.addEventListener("click", async (event) => {
        const button = event.target.closest("button[data-action]");
        if (!button) return;
        const ayahNumber = Number(button.dataset.ayah);
        const action = button.dataset.action;
        if (action === "jump") {
          const page = Number(button.dataset.page);
          state.pendingHighlightAyahNumber = ayahNumber;
          await loadPage(page);
          return;
        }
        const idx = state.bookmarks.findIndex((bookmark) => bookmark.number === ayahNumber);
        if (idx < 0) return;
        if (action === "remove") {
          state.bookmarks.splice(idx, 1);
        } else if (action === "note") {
          const note = window.prompt("Edit note:", state.bookmarks[idx].note || "");
          if (note === null) return;
          state.bookmarks[idx].note = note.trim();
        }
        persistBookmarks();
        renderBookmarks();
        updateAyahButtons();
      });

      els.surahList.addEventListener("click", async (event) => {
        const button = event.target.closest(".surah-btn[data-surah]");
        if (!button) return;
        const surahNumber = Number(button.dataset.surah);
        if (!Number.isFinite(surahNumber)) return;
        setLoading(true, "Finding Surah opening page...");
        clearError();
        try {
          const page = await getSurahStartPage(surahNumber);
          await loadPage(page);
        } catch (error) {
          showError(`Could not jump to Surah ${surahNumber}: ${error.message}`);
        } finally {
          setLoading(false);
        }
      });

      els.ayahContainer.addEventListener("click", (event) => {
        const playButton = event.target.closest(".ayah-play-btn[data-ayah-index]");
        if (playButton) {
          handleAyahPlayButton(Number(playButton.dataset.ayahIndex));
          return;
        }
        const bookmarkButton = event.target.closest(".ayah-bookmark-btn[data-ayah-index]");
        if (bookmarkButton) {
          toggleBookmark(Number(bookmarkButton.dataset.ayahIndex));
          return;
        }
        const noteButton = event.target.closest(".ayah-note-btn[data-ayah-index]");
        if (noteButton) {
          updateAyahNote(Number(noteButton.dataset.ayahIndex));
          return;
        }
        const wordChip = event.target.closest(".word-chip[data-word]");
        if (wordChip) {
          const decodedWord = decodeURIComponent(wordChip.dataset.word || "");
          showWordTooltip(decodedWord, wordChip.getBoundingClientRect());
        } else {
          hideWordTooltip();
        }
      });

      els.ayahContainerSecondary.addEventListener("click", (event) => {
        const wordChip = event.target.closest(".word-chip[data-word]");
        if (wordChip) {
          const decodedWord = decodeURIComponent(wordChip.dataset.word || "");
          showWordTooltip(decodedWord, wordChip.getBoundingClientRect());
        } else {
          hideWordTooltip();
        }
      });

      document.addEventListener("click", (event) => {
        if (!event.target.closest(".word-chip")) hideWordTooltip();
      });
      window.addEventListener("scroll", hideWordTooltip, { passive: true });

      document.addEventListener("keydown", (event) => {
        const targetTag = event.target.tagName;
        const isField = /INPUT|TEXTAREA|SELECT|BUTTON/.test(targetTag) || event.target.isContentEditable;
        if (isField) return;
        if (event.code === "Space") {
          event.preventDefault();
          toggleGlobalPlayPause();
        } else if (event.key === "ArrowRight") {
          event.preventDefault();
          loadPage(state.currentPage + pageStep());
        } else if (event.key === "ArrowLeft") {
          event.preventDefault();
          loadPage(state.currentPage - pageStep());
        } else if (event.key === "ArrowDown") {
          event.preventDefault();
          playRelativeAyah(1);
        } else if (event.key === "ArrowUp") {
          event.preventDefault();
          playRelativeAyah(-1);
        }
      });

      els.audio.addEventListener("play", () => {
        updateWordCursorForCurrentAyah();
        updateButtons();
        updateAyahButtons();
      });

      els.audio.addEventListener("pause", () => {
        updateButtons();
        updateAyahButtons();
      });

      els.audio.addEventListener("timeupdate", () => {
        updateWordCursorForCurrentAyah();
      });

      els.audio.addEventListener("loadedmetadata", () => {
        updateWordCursorForCurrentAyah();
      });

      els.audio.addEventListener("seeking", () => {
        updateWordCursorForCurrentAyah();
      });

      els.audio.addEventListener("ended", async () => {
        if (state.currentPlaybackPhase === "arabic") {
          setWordCursorCompletedForCurrentAyah();
          const playedTranslation = await playSelectedTranslationForCurrentAyah();
          if (playedTranslation) {
            updateButtons();
            updateAyahButtons();
            return;
          }
        }
        state.currentPlaybackPhase = "arabic";
        if (state.currentAyahRepeatLeft > 1) {
          state.currentAyahRepeatLeft -= 1;
          await playAyah(state.currentAyahIndex, state.isFullPageMode, { resetRepeatCounter: false });
          return;
        }
        state.currentAyahRepeatLeft = Math.max(1, state.repeatAyahCount);
        if (!state.isFullPageMode) {
          updateButtons();
          updateAyahButtons();
          return;
        }

        const range = getRangeBoundIndexes();
        const nextIndex = state.currentAyahIndex + 1;
        if (range.enabled) {
          if (nextIndex <= range.end) {
            await playAyah(nextIndex, true);
            return;
          }
          if (state.pageLoop) {
            await playAyah(range.start, true);
            return;
          }
          state.isFullPageMode = false;
          updatePlayerText(`Completed selected range on page ${state.currentPage}`);
          updateButtons();
          updateAyahButtons();
          return;
        }

        if (nextIndex < state.ayahs.length) {
          await playAyah(nextIndex, true);
          return;
        }
        if (state.pageLoop) {
          await playAyah(0, true);
          return;
        }
        if (state.continueAcrossPages && state.currentPage < maxPrimaryPageForMode()) {
          await loadPage(state.currentPage + pageStep(), { preserveMode: true });
          if (state.ayahs.length) {
            state.isFullPageMode = true;
            await playAyah(0, true);
            return;
          }
        }

        state.isFullPageMode = false;
        updatePlayerText(`Completed Page ${state.currentPage}`);
        updateButtons();
        updateAyahButtons();
      });

      els.audio.addEventListener("error", () => {
        state.isFullPageMode = false;
        updateButtons();
        updateAyahButtons();
        showError("Audio playback failed. Try another reciter or Ayah.");
      });
    }

    async function init() {
      loadPersistedState();
      initSelects();
      renderBookmarks();
      renderProgress();
      bindEvents();
      updateButtons();
      updatePlayerText("Ready");
      await loadSurahList();
      await loadPage(state.currentPage);
    }

    init();
  </script>
</body>
</html>
